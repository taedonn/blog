---
title: "[정보처리기사] #26 디자인 패턴"
date: 2024-05-01 20:06:00 +0900
categories: [정보처리기사]
tags: [정보처리기사, 정처기, design pattern, 디자인 패턴, gof, gang of four, creational pattern, 생성 패턴, abstract factory, 추상 팩토리, builder, 빌더, factory method, 팩토리 메소드, prototype, 프로토타입, singleton, 싱글톤, structural pattern, 구조 패턴, adapter, 어댑터, bridge, 브리지, composite, 컴포지트, decorator, 데코레이터, facade, 퍼싸드, flyweight, 플라이웨이트, proxy, 프록시, behavioral pattern, 행위 패턴, chain of responsibility, 책임 연쇄, command, 커멘드, interpreter, 인터프리터, iterator, 반복자, mediator, 중재자, memento, 메멘토, observer, 옵서버, state, 상태, strategy, 전략, template method, 템플릿 메소드, visitor, 방문자]
image:
    path: /assets/img/2024-04-22-38/2024-04-22-38-1.jpg
    alt: 시나공 정보처리기사 필기
published: false
---

### 1. 디자인 패턴(Design Pattern)의 개요

디자인 패턴은 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 **세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식** 또는 예제를 의미합니다.

- 디자인 패턴은 재사용할 수 있는 기본형 코드들이 포함되어 있습니다.
- 개발 과정 중에 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적입니다.
- 디자인 패턴은 한 패턴에 변형을 가하거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화되는 특징이 있습니다.
- 디자인 패턴은 1995년 GoF(Gang of Four)라고 불리는 에릭 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블라시디스(John Vissides)가 처음으로 구체화 및 체계화 하였습니다.
- GoF의 디자인 패턴은 수많은 디자인 패턴들 중 가장 일반적인 사례에 적용될 수 있는 패턴들을 분류하여 정리함으로써, 지금까지도 소프트웨어 공학이나 현업에서 가장 많이 사용되는 디자인 패턴입니다.
- GoF의 디자인 패턴은 유형에 따라 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개로 총 23개의 패턴으로 구성됩니다.

#### 아키텍처 패턴 vs 디자인 패턴

두 패턴은 모두 소프트웨어 설계를 위한 참조모델이지만 다음과 같은 차이가 있습니다.

- 아키텍처 패턴은 디자인 패턴보다 상위 수준의 설계에 사용됩니다.
- 아키텍처 패턴이 전체 시스템의 구조를 설계하기 위한 참조 모델이라면, 디자인 패턴은 서브시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조 모델입니다.
- 몇몇 디자인 패턴은 특정 아키텍처 패턴을 구현하는데 유용하게 사용됩니다.

&nbsp;

### 2. 생성 패턴(Creational Pattern)

생성 패턴은 객체의 생성과 관련된 패턴으로 총 5개의 패턴이 있습니다.

- 생성 패턴은 **객체의 생성과 참조 과정을 캡슐화**하여 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 하여 프로그램에 유연성을 더해줍니다.

<table>
    <tr>
        <td>
            추상 팩토리<br>
            (Abstract Factory)
        </td>
        <td>
            - 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관, <br>
            의존하는 객체들의 그룹으로 생성하여 <u>추상적으로 표현</u>합니다.<br>
            - 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능합니다.
        </td>
    </tr>
    <tr>
        <td>빌더(Builder)</td>
        <td>
            - 작게 분리된 인스턴스를 <u>건축 하듯이 조합</u>하여 객체를 생성합니다.<br>
            - 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 <br>
            생성에서도 서로 다른 결과를 만들어 낼 수 있습니다.
        </td>
    </tr>
    <tr>
        <td>
            팩토리 메소드<br>
            (Factory Method)
        </td>
        <td>
            - <u>객체 생성을 서브 클래스에서 처리하도록 분리</u>하여 캡슐화한 패턴입니다.<br>
            - 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당합니다.
        </td>
    </tr>
    <tr>
        <td>프로토타입(Prototype)</td>
        <td>
            - <u>원본 객체를 복제</u>하는 방법으로 객체를 생성하는 패턴입니다.<br>
            - 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용합니다.
        </td>
    </tr>
    <tr>
        <td>싱글톤(Singleton)</td>
        <td>
            - 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, <br>
            여러 프로세스가 동시에 참조할 수는 없습니다.<br>
            - <u>클래스 내에서 인스턴스가 하나뿐임을 보장</u>하며, 불필요한 메모리 <br>
            낭비를 최소화 할 수 있습니다.
        </td>
    </tr>
</table>

&nbsp;

### 3. 구조 패턴(Structural Pattern)

- 구조 패턴을 클래스나 객체들을 조합하여 더 큰 구조를 만들 수 있게 해주는 패턴으로 총 7개의 패턴이 있습니다.
- 구조 패턴은 구조가 복잡한 시스템을 개발하기 쉽게 도와줍니다.

<table>
    <tr>
        <td>어댑터(Adapter)</td>
        <td>
            - 호환성이 없는 클래스들의 인터페이스를 <u>다른 클래스가 이용할 수 있도록 변환</u>해주는 패턴입니다.<br>
            - 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용합니다.
        </td>
    </tr>
    <tr>
        <td>브리지(Bridge)</td>
        <td>
            - <u>구현부에서 추상층을 분리</u>하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴입니다.<br>
            - 기능과 구현을 두 개의 별도 클래스로 구현합니다.
        </td>
    </tr>
    <tr>
        <td>컴포지트(Composite)</td>
        <td>
            - 여러 객체를 가진 <u>복합 객체와 단일 객체를 구분 없이 다루고자 할 때</u> 사용하는 패턴입니다.<br>
            - 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 <br>
            복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있습니다.
        </td>
    </tr>
    <tr>
        <td>데코레이터(Decorator)</td>
        <td>
            - 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴입니다.<br>
            - 임의의 객체에 부가적인 기능을 추가하기 위해 <br>
            <u>다른 객체들을 덧붙이는 방식</u>으로 구현합니다.
        </td>
    </tr>
    <tr>
        <td>퍼싸드(Facade)</td>
        <td>
            - <u>복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성</u>함으로써 <br>
            서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴입니다.<br>
            - 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요합니다.
        </td>
    </tr>
    <tr>
        <td>플라이웨이트(Flyweight)</td>
        <td>
            - 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 <br>
            <u>공유해서 사용</u>함으로써 메모리를 절약하는 패턴입니다.<br>
            - 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있습니다.
        </td>
    </tr>
    <tr>
        <td>프록시(Proxy)</td>
        <td>
            - 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 <br>
            <u>인터페이스 역할</u>을 수행하는 패턴입니다.<br>
            - 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용합니다.
        </td>
    </tr>
</table>

&nbsp;

### 4. 행위 패턴(Behavioral Pattern)

- 행위 패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로 총 11개의 패턴이 있습니다.
- 행위 패턴은 **하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화** 할 수 있도록 도와줍니다.

<table>
    <tr>
        <td>
            책임 연쇄<br>
            (Chain of Responsibility)
        </td>
        <td>
            - 요청을 처리할 수 있는 객체가 둘 이상 존재하여 <br>
            <u>한 객체가 처리하지 못하면 다음 객체로 넘어가는 형식</u>의 패턴입니다.<br>
            - 요청을 처리할 수 있는 각 객체들이 고리(Chain)로 묶여 있어 <br>
            요청이 해결될 때까지 고리를 따라 책임이 넘어갑니다.
        </td>
    </tr>
    <tr>
        <td>커멘드(Command)</td>
        <td>
            - 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 <br>
            <u>요청에 필요한 정보를 저장</u>하거나 로그에 남기는 패턴입니다.<br>
            - 요청에 사용되는 명령어들을 추상 클래스와 구체 클래스*로 분리해 단순화합니다.
        </td>
    </tr>
    <tr>
        <td>인터프리터(Interpreter)</td>
        <td>
            - <u>언어에 문법 표현을 정의</u>하는 패턴입니다.<br>
            - SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용합니다.
        </td>
    </tr>
    <tr>
        <td>반복자(Iterator)</td>
        <td>
            - 자료 구조와 같이 접근이 잦은 객체에 대해 <br>
            <u>동일한 인터페이스를 사용</u>하도록 하는 패턴입니다.<br>
            - 내부 표현 방법의 노출 없이 순차적인 접근이 가능합니다.
        </td>
    </tr>
    <tr>
        <td>중재자(Mediator)</td>
        <td>
            - 수많은 객체들 간의 복잡한 <u>상호작용(Interface)을 캡슐화</u>하여 <br>
            객체로 정의하는 패턴입니다.<br>
            - 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있습니다.
        </td>
    </tr>
    <tr>
        <td>메멘토(Memento)</td>
        <td>
            - 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라<br>
            <u>객체를 해당 시점의 상태로 돌릴 수 있는 기능</u>을 제공하는 패턴입니다.<br>
            - Ctrl + Z와 같은 기능을 개발할 때 주로 사용합니다.
        </td>
    </tr>
    <tr>
        <td>옵서버(Observer)</td>
        <td>
            - 한 객체의 상태가 변화하면 객체에 상속되어 있는 <br>
            다른 객체들에게 <u>변화된 상태를 전달</u>하는 패턴입니다.<br>
            - 주로 분산된 시스템 간에 이벤트를 생성, 발행(Publish)하고, <br>
            이를 수신(Subscribe)해야 할 때 사용합니다.
        </td>
    </tr>
    <tr>
        <td>상태(State)</td>
        <td>
            - 객체의 <u>상태에 따라 동일한 동작을 다르게 처리</u>해야 할 때 <br>
            사용하는 패턴입니다.<br>
            - 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리합니다.
        </td>
    </tr>
    <tr>
        <td>전략(Strategy)</td>
        <td>
            - 동일한 계열의 알고리즘들을 개별적으로 <u>캡슐화하여 상호 교환</u>할 수 있게 <br>
            정의하는 패턴입니다.<br>
            - 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, <br>
            클라이언트에 영향 없이 알고리즘의 변경이 가능합니다.
        </td>
    </tr>
    <tr>
        <td>
            템플릿 메소드<br>
            (Template Method)
        </td>
        <td>
            - 상위 클래스에서 골격을 정의하고, 하위 클래스에서 <br>
            세부 처리를 구체화하는 구조의 패턴입니다.<br>
            - 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에 <br>
            정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해줍니다.
        </td>
    </tr>
    <tr>
        <td>방문자(Visitor)</td>
        <td>
            - 각 클래스들의 <u>데이터 구조에서 처리 기능을 분리</u>하여 <br>
            별도의 클래스로 구성하는 패턴입니다.
        </td>
    </tr>
</table>

> *추상 클래스(Abstract Class)는 구체 클래스에서 구현하려는 기능들의 공통점만을 모아 추상화한 클래스를 의미합니다.
{: .prompt-tip }

> *구체 클래스(Concrete Class)는 인스턴스 생성이 가능한 일반 클래스를 의미합니다.
{: .prompt-tip }

&nbsp;

### 기출 문제

**1. (보기1)의 디자인 패턴 분류와 (보기2)의 디자인 패턴을 바르게 연결한 것은?**

(보기1) ㄱ.생성 패턴 ㄴ.구조 패턴 ㄷ.행위 패턴

(보기2) a.Prototype b.Facade c.Command

1. ㄱ-a, ㄴ-b, ㄷ-c
2. ㄱ-b, ㄴ-a, ㄷ-c
3. ㄱ-c, ㄴ-a, ㄷ-b
4. ㄱ-a, ㄴ-c, ㄷ-b

> Prototype은 생성 패턴, Facade는 구조 패턴, Command는 행위 패턴입니다. 따라서 정답은 **1번**입니다.
{: .prompt-info }

&nbsp;

**2. Iterator 패턴에 대한 설명으로 옳지 않은 것은?**

1. 내부 표현 방법의 노출 없이 접근이 가능하다.
2. 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있다.
3. 배열이나 리스트 같은 자료 구조를 처리하는 데 사용된다.
4. 집합 객체의 각 요소들에 대해 순차 접근하는 방식이다.

> Iterator는 행위 패턴으로 독립적으로 사용할 수 없는 패턴입니다. 따라서 정답은 **2번**입니다.
{: .prompt-info }

&nbsp;

**3. 다음에서 설명하는 디자인 패턴에 해당하는 것은?**

> 기존에 만들어진 클래스를 사용하려고 하는데 인터페이스가 일치하지 않거나, 관련이 없어 사용하지 못했던 클래스들을 다시 사용할 수 있게 만들고자 한다.

1. Command
2. Factory Method
3. Adapter
4. Memento

> 사용하지 못했던 클래스들을 다시 사용할 수 있게 '변환'하는 패턴은 Adapter 패턴입니다. 따라서 정답은 **3번**입니다.
{: .prompt-info }

&nbsp;

**4. 다음 중 디자인 패턴에 대한 설명으로 가장 거리가 먼 것은?**

1. 객체의 생성과 표현이 분리되어 있어, 동일한 객체 생성에도 다른 결과를 내야 할 때는 빌더 패턴이 권장된다.
2. 메모리를 절약하기 위해 인스턴스를 공유해서 사용할 때는 플라이웨이트 패턴이 권장된다.
3. 관련된 객체들의 묶음을 스타일 선택에 의해서 생성할 때는 프로토타입 패턴이 권장된다.
4. 각 클래스의 처리 기능을 분리하여 캡슐화 한 후 필요할 때마다 해당 클래스에 방문해서 처리할 때는 비지터 패턴이 권장된다.

> 프로토타입 패턴은 객체를 복사해서 사용하는 패턴입니다. 따라서 정답은 **3번**입니다.
{: .prompt-info }

&nbsp;

**5. 다음 중 유형이 다른 디자인 패턴끼리 연결된 것은?**

1. Builder Pattern - Prototype Pattern
2. Singleton Pattern - Abstract Factory Pattern
3. Bridge Pattern - Proxy Pattern
4. Chain of Responsibility Pattern - Facade Pattern

> 책임 연쇄 패턴(Chain of Responsibility)은 행위 패턴에 속하고, 퍼싸드 패턴(Facade Pattern)은 구조 패턴에 속합니다. 따라서 정답은 **4번**입니다.
{: .prompt-info }

&nbsp;

**6. 다음 설명에 해당하는 디자인 패턴은?**

문제) Java에서 new를 통해 인스턴스를 매번 생성하다보니 메모리 사용량이 급격하게 증가하였다. 이로 인해 프로그램이 무거워져서 원할한 사용을 위해 수정이 불가피해졌다. 어떻게 해결하는가?

해결책) 동일한 객체가 존재할 경우 해당 객체를 공유하여 사용함으로써 메모리를 절약하고, 존재하지 않을 경우만 새로 객체를 생성하여 사용하도록 한다.

1. Adapter 패턴
2. Bridge 패턴
3. Flyweight 패턴
4. Chain of Responsibility 패턴

> '공유'와 '메모리 절약'에 해당하는 디자인 패턴은 플라이웨이트(Flyweight) 패턴입니다. 따라서 정답은 **3번**입니다.
{: .prompt-info }