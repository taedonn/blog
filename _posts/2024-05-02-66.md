---
title: "[정보처리기사] 예상 기출 문제 #20 ~ #26"
date: 2024-05-02 17:44:00 +0900
categories: [정보처리기사]
tags: [정보처리기사, 정처기, 기출 문제, 예상 기출 문제]
image:
    path: /assets/img/2024-04-22-38/2024-04-22-38-1.jpg
    alt: 시나공 정보처리기사 필기
published: false
---

### 1. 소프트웨어 아키텍처 설계에 있어서 정보 은폐(Information Hiding)의 근본적인 목적은?

1. 코드를 개선하기 위해
2. 코드의 길이를 짧게 하기 위해
3. 고려되지 않은 영향(Side Effect)들을 최소화하기 위하여
4. 인터페이스를 최소화하기 위하여

> 정답은 **3번**입니다.
{: .prompt-info }

&nbsp;

### 2. 추상화의 유형에서 이벤트 발생의 구체적인 절차 또는 방법을 정의하지 않고 대표할 수 있는 표현으로 대체하는 것을 무엇이라고 하는가?

1. 과정 추상화
2. 데이터 추상화
3. 제어 추상화
4. 이벤트 추상화

> 추상화의 유형에는 과정 추상화, 데이터 추상화, 제어 추상화가 있습니다. 설명에 대한 정답은 **3번**입니다.
{: .prompt-info }

&nbsp;

### 3. 소프트웨어 아키텍처 설계에 대한 설명으로 옳지 않은 것은?

1. 이해 관계자들의 의사소통 도구로 활용된다.
2. 설계된 모듈을 프로그래밍 언어를 통해 구현한다.
3. 애플리케이션을 모듈로 분할하고, 모듈 간 인터페이스를 결정하는 과정이다.
4. 기본 원리에는 모듈화, 추상화, 단계적 분해, 정보은닉이 있다.

> 2번의 설명은 아키텍처 설계가 아닌 아키텍처 구현에 관한 내용입니다. 따라서 정답은 **2번**입니다.
{: .prompt-info }

&nbsp;

### 4. 소프트웨어 아키텍처의 품질 속성 중 다음 설명이 의미하는 것은?

- 개발 비용을 더 투자하여 유연성이 높은 아키텍처를 만들 것인지를 결정하는 것이다.
- 유연성이 떨어지는 경우 이후 유지보수에 많은 비용이 소모될 수 있다는 것을 고려해야 한다.

1. 비용과 혜택
2. 시장 적시성
3. 가용성
4. 구축 가능성

> 비용에 관한 내용은 비용과 혜택 품질 속성에 해당합니다. 따라서 정답은 **1번**입니다.
{: .prompt-info }

&nbsp;

### 5. 소프트웨어 아키텍처의 설계 과정을 순서대로 가장 옳게 나열한 것은?

가. 시스템과 서브시스템의 타입을 결정한다.
나. 서브시스템의 기능과 서브시스템 간의 인터페이스를 정의한다.
다. 표준 아키텍처를 설계한다.
라. 요구사항을 분석하여 전체 시스템의 설계 목표를 설정한다.

1. 라 -> 가 -> 나 -> 다
2. 라 -> 나 -> 가 -> 다
3. 라 -> 다 -> 가 -> 나
4. 라 -> 가 -> 다 -> 나

> 소프트웨어 아키텍처의 설계 과정은 설계 목표 설정, 시스템 타입 결정, 아키텍처 패턴 적용, 서브 시스템 구체화, 검토 순입니다. 따라서 정답은 **4번**입니다.
{: .prompt-info }

&nbsp;

### 6. 다음 그림은 MVC(Model-View-Controller) 아키텍처 패턴을 나타낸 것이며, 세 가지 요소가 별도의 컴포넌트로 구성된다. 각 (가), (나), (다)에 해당하는 요소를 바르게 나열한 것은?

![예시 6](/assets/img/2024-05-02-66/2024-05-02-66-1.png)

1. (가) 컨트롤러, (나) 모델, (다) 뷰
2. (가) 모델, (나) 뷰, (다) 컨트롤러
3. (가) 뷰, (나) 모델, (다) 컨트롤러
4. (가) 컨트롤러, (나) 뷰, (다) 모델

> 컨트롤러에 인풋이 요청되면 뷰를 제어하고, 모델의 데이터를 갱신합니다. 따라서 정답은 **1번**입니다.
{: .prompt-info }

&nbsp;

### 7. 아키텍처의 패턴에 관한 설명 중 옳지 않은 것은?

1. 레이어 패턴은 하위 계층이 제공하는 서비스를 상위 계층의 서브시스템이 사용하도록 구성된다.
2. 브로커 패턴은 사용자가 원하는 서비스와 특성을 요청하면, 적합한 컴포넌트를 연결해준다.
3. 이벤트-버스 패턴은 이벤트 메시지를 발행하고 구독하는 형태로 이루어진다.
4. 피어-투-피어 패턴에서 각 서브시스템은 서비스를 요청하고 제공하는 능력이 있다.

> 레이어 패턴은 상위 계층의 서비스를 하위 계층의 서브시스템이 사용하도록 구성된 패턴입니다. 따라서 정답은 **1번**입니다.
{: .prompt-info }

&nbsp;

### 8. 다음은 아키텍처 스타일과 이를 기반으로 하는 시스템의 관계를 짝지은 것으로 가장 옳지 않은 것은?

1. Layer Pattern - OSI 참조 모델
2. Master-Slave Pattern - 장애 허용 시스템
3. Blackboard Pattern - 차량 식별 시스템
4. MVC Pattern - 병렬 컴퓨팅 시스템

> MVC 패턴은 대화형 애플리케이션에 적합하며, 병렬 컴퓨팅 시스템에 적합한 패턴은 마스터-슬레이브 패턴입니다. 따라서 정답은 **4번**입니다.
{: .prompt-info }

&nbsp;

### 9. 아키텍처 패턴(Architecture Pattern)의 장점에 해당하지 않는 것은?

1. 시행착오를 줄여 개발시간이 최대화되고, 고품질의 소프트웨어를 생산할 수 있다.
2. 전형적인 아키텍처를 기반으로 이해를 공유하여 개발자들 간의 의사소통이 편해진다.
3. 개발에 참여하지 않아도 시스템의 이해가 쉬워 유지보수가 용이하다.
4. 시스템 개발 전에 시스템의 특성을 예측할 수 있다.

> 시행착오를 줄여 개발시간을 최대화가 아닌 최소화합니다. 따라서 정답은 **1번**입니다.
{: .prompt-info }

&nbsp;

### 10. 다음이 설명하고 있는 아키텍처 패턴은?

- 데이터 변환 시스템과 같이 데이터 스트림을 처리해야 하는 소프트웨어에서 주로 사용된다.
- 한 모듈이 데이터 스트림을 입력받아 처리하면, 다음 모듈이 이어받아 처리하는 형식이다.
- 모듈의 재사용과 추가가 간편하여 확장성이 뛰어나다.

1. MVC Pattern
2. Pipe-Filter Pattern
3. Peer-to-Peer Pattern
4. Broker Pattern

> 데이터 변환 시스템과 같은 소프트웨어에서 주로 사용되는 패턴은 Pipe-Filter Pattern입니다. 따라서 정답은 **2번**입니다.
{: .prompt-info }

&nbsp;

### 11. 객체지향 프로그램의 장점으로 거리가 먼 것은?

1. 자연적인 모델링이 가능하다.
2. 실행 속도가 빨라진다.
3. 소프트웨어의 재사용률이 높아진다.
4. 소프트웨어의 유지보수성이 향상된다.

> 객체지향 기존 절차지향 방식보다 속도가 느리다는 단점이 있습니다. 따라서 정답은 **2번**입니다.
{: .prompt-info }

&nbsp;

### 12. 객체에 대한 특성을 설명한 것으로 가장 옳지 않은 것은?

1. 객체마다 각각의 상태를 갖고 있다.
2. 식별성을 가진다.
3. 행위에 대하여 그 특징을 나타낼 수 있다.
4. 일정한 기억장소를 가지고 있지 않다.

> 객체는 일정한 기억장소를 가지고 있습니다. 따라서 정답은 **4번**입니다.
{: .prompt-info }

&nbsp;

### 13. 객체지향 개념 중 하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 데이터 추상화를 의미하는 것은?

1. 메소드(Method)
2. 클래스(Class)
3. 상속성(Inheritance)
4. 추상화(Abstraction)

> 정답은 **2번**입니다.
{: .prompt-info }

&nbsp;

### 14. 객체지향 개념에서 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정을 무엇이라고 하는가?

1. 정보 은닉(Information Hiding)
2. 클래스(Class)
3. 캡슐화(Encapsulation)
4. 통합(Integration)

> 캡슐화는 인터페이스를 제외한 세부 내용을 은폐하여 필요한 부분만 밖으로 드러내는 것을 말합니다. 따라서 정답은 **3번**입니다.
{: .prompt-info }

&nbsp;

### 15. 객체지향 기법에서 상속(Inheritance)의 결과로 얻을 수 있는 가장 주요한 이점은?

1. 모듈 라이브러리의 재이용
2. 객체지향 DB를 사용할 수 있는 능력
3. 클래스와 오브젝트들을 재사용할 수 있는 능력
4. 프로젝트들을 보다 효과적으로 관리할 수 있는 능력

> 상속은 상위 클래스에서 정의한 속성과 연산을 하위 클래스에서 쓸 수 있기 때문에 소프트웨어의 재사용성을 높입니다. 따라서 정답은 **3번**입니다.
{: .prompt-info }

&nbsp;

### 16. ASCII File을 print하는 method를 갖고 있는 object, Binary File을 print하는 method를 갖고 있는 object, Picture File을 print하는 method를 갖고 있는 object들을 모두 "print"라는 method를 갖고 있으므로, "print"라는 메시지를 받으면 수행하게 된다. 그러나 각각의 method에서 print를 수행하는 방법은 모두 다를 것이다. 객체지향에서 시스템에서 이와 같이 서로 다른 class들이 같은 의미의 응답을 하는 특성을 무엇이라고 하는가?

1. 캡슐화(Encapsulation)
2. 상속성(Inheritance)
3. 다형성(Polymorphism)
4. 추상화(Abstraction)

> 다형성은 하나의 메시지(print)에 대해 각각의 클래스가 가지고 있는 고유한 방법(ASCII File, Binary File 등)으로 응답하는 능력을 말합니다. 따라서 정답은 **3번**입니다.
{: .prompt-info }

&nbsp;

### 17. 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 경우, 이를 무슨 결합이라고 하는가?

1. 내용 결합
2. 제어 결합
3. 공통 결합
4. 스탬프 결합

> 설명에 대한 답은 내용 결합(Content Coupling)입니다. 내용 결합은 결합도가 가장 높은 결합입니다. 따라서 정답은 **1번**입니다.
{: .prompt-info }

&nbsp;

### 18. 두 모듈이 동일한 자료 구조를 조회하는 경우의 결합성이며 자료 구조의 어떠한 변화, 즉 포맷이나 구조의 변화는 그것을 조회하는 모든 모듈 및 변화되는 필드를 실제로 조회하지 않는 모듈에 까지도 영향을 미치게 되는 결합성은?

1. Data Coupling
2. Stamp Coupling
3. Control Coupling
4. Content Coupling

> 정답은 **2번**입니다.
{: .prompt-info }

&nbsp;

### 19. 결합도(Coupling)에 대한 설명으로 틀린 것은?

1. 데이터 결합도(Data Coupling)는 두 모듈이 매개변수로 자료를 전달할 때 자료 구조 형태로 전달되어 이용될 때 데이터가 결합되어 있다고 한다.
2. 내용 결합도(Content Coupling)는 하나의 모듈이 직접적으로 다른 모듈의 내용을 참조할 때 두 모듈은 내용적으로 결합되어 있다고 한다.
3. 공통 결합도(Common Coupling)는 두 모듈이 동일한 전역 데이터를 접근한다면 공통 결합되어 있다고 한다.
4. 결합도(Coupling)는 두 모듈간의 상호작용, 또는 의존도 정도를 나타내는 것이다.

> 데이터를 매개 변수나 인수로 전달할 때 데이터 결합이라고 하며, 자료 구조로 전달할 때는 스탬프 결합이라고 합니다. 따라서 정답은 **1번**입니다.
{: .prompt-info }

&nbsp;

### 20. 모듈의 응집도(Cohesion)에 대한 설명 중 틀린 것은?

1. 모듈의 응집도란 모듈 안의 요소들이 서로 관련되어 있는 정도를 말한다.
2. 기능적 응집도(Functional Cohesion)는 한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 요소의 입력 자료로서 제공되는 형태이다.
3. 교환적 응집도(Communication Cohesion)는 동일한 입력과 출력을 사용하는 소작업들이 모인 모듈에서 볼 수 있다.
4. 논리적 응집도(Logical Cohesion)는 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우이다.

> 2번의 내용은 순차적 응집도(Sequential Cohesion)에 관한 설명입니다. 따라서 정답은 **2번**입니다.
{: .prompt-info }

&nbsp;

### 21. 응집도의 종류 중 서로 간에 어떠한 의미 있는 연관관계도 지니지 않은 기능 요소로 구성되며, 서로 다른 상위 모듈에 의해 호출되어 처리상의 연관성이 없는 서로 다른 기능을 수행하는 경우의 응집도는?

1. Coincidental Cohesion
2. Functional Cohesion
3. Sequential Cohesion
4. Logical Cohesion

> 정답은 **1번**입니다.
{: .prompt-info }

&nbsp;

### 22. 모듈을 설계하기 위해서 바람직한 응집도(Cohesion)와 결합도(Coupling)의 관계는?

1. 응집도는 약하고 결합도는 강해야 한다.
2. 응집도는 강하고 결합도는 약해야 한다.
3. 응집도도 약하고 결합도도 약해야 한다.
4. 응집도도 강하고 결합도도 강해야 한다.

> 바람직한 모듈은 결합도가 약하고 응집도가 강해야 합니다. 따라서 정답은 **2번**입니다.
{: .prompt-info }

&nbsp;

### 23. 다음은 소프트웨어의 구성 요소인 모듈의 계층적 구성을 나타내는 프로그램 구조도이다. 모듈 G에서의 팬인(Fan In)과 팬아웃(Fan Out)은?

> p.125의 예시 참조

1. 팬인 : 1, 팬아웃 : 2
2. 팬인 : 2, 팬아웃 : 1
3. 팬인 : 2, 팬아웃 : 3
4. 팬인 : 3, 팬아웃 : 1

> 정답은 **2번**입니다.
{: .prompt-info }

&nbsp;

### 24. 효과적인 모듈 설계 방법으로 가장 거리가 먼 것은?

1. Coupling은 약하게 Cohesion은 강하게 설계해야 한다.
2. Complexity는 줄이고 Redundancy를 최대한 늘릴 수 있도록 설계한다.
3. Maintenance가 용이하도록 설계한다.
4. Module 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 설계한다.

> 모듈의 중복성(Redundancy)은 가능한 최소화 하는 게 좋습니다. 따라서 정답은 **2번**입니다.
{: .prompt-info }

&nbsp;

### 25. 소프트웨어 재사용에 대한 내용 중 옳지 않은 것은?

1. 비용을 절감하고 개발 시간을 단축하여 생산성이 크게 증가한다.
2. 재사용되는 대상은 외부 모듈과의 결합도가 낮아야 한다.
3. 규모에 따라 변수, 함수, 객체, 컴포넌트 단위로 재사용된다.
4. 재사용을 위해서는 사용법이 공개되어야 한다.

> 규모에 따른 재사용 대상들에는 함수, 객체(클래스, 메소드), 컴포넌트, 애플리케이션이 있습니다. 따라서 정답은 **3번**입니다.
{: .prompt-info }

&nbsp;

### 26. 공통 모듈을 설계할 때 공통 부분을 명세하기 위한 기법에 해당하지 않는 것은?

1. 독립성
2. 명확성
3. 일관성
4. 정확성

> 공통 부분을 명세하기 위한 기법에는 정확성(Correctness), 명확성(Clarity), 완전성(Completeness), 일관성(Consistency), 추적성(Traceability)이 있습니다. 따라서 정답은 **1번**입니다.
{: .prompt-info }

&nbsp;

### 27. 코드화 대상 항목을 10진 분할하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 코드로서, 코드 대상 항목의 추가가 용이하며 무제한적으로 확대할 수 있으나 자릿수가 길어질 수 있고 기계 처리에는 적합하지 않은 코드는?

1. Sequence Code
2. Group Classification Code
3. Block Code
4. Decimal Code

> 정답은 **4번**입니다.
{: .prompt-info }

&nbsp;

### 28. 다음과 같이 주로 도서 분류 코드에 사용되는 코드는?

<table>
    <thead>
        <tr>
            <td>도서 목록</td>
            <td>부여 코드</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>국문학</td>
            <td>100</td>
        </tr>
        <tr>
            <td>철학</td>
            <td>200</td>
        </tr>
        <tr>
            <td>정보학</td>
            <td>300</td>
        </tr>
    </tbody>
</table>

1. 10진 코드
2. 순서 코드
3. 문자 코드
4. 분류 코드

> 10진 코드는 다른 말로 도서 분류식 코드라고도 합니다. 따라서 정답은 **1번**입니다.
{: .prompt-info }

&nbsp;

### 29. 코드의 종류 중 코드화 대상 항목을 자료의 발생 순서, 크기 순서, 가나다라 순서 등과 같이 어떤 일정한 기준에 따라 일련 번호를 부여하는 것은?

1. Block Code
2. Group Code
3. Sequence Code
4. Decimal Code

> 차례로 일련 번호를 부여하는 코드의 종류는 순차 코드(Sequence Code) 입니다. 따라서 정답은 **3번**입니다.
{: .prompt-info }

&nbsp;

### 30. 다음과 같은 표현 방법으로 부여하는 코드는?

<table>
    <thead>
        <tr>
            <td>제품</td>
            <td>부여 코드</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>냉장고(235L)</td>
            <td>RF-235</td>
        </tr>
        <tr>
            <td>형광등(30W 220V 흰색)</td>
            <td>K-30-220-W</td>
        </tr>
        <tr>
            <td>텔레비전(17인치 흑백)</td>
            <td>T-17</td>
        </tr>
        <tr>
            <td>텔레비전(25인치 컬러)</td>
            <td>T-25-C</td>
        </tr>
    </tbody>
</table>

1. Sequence Code
2. Mnemonic Code
3. Block Code
4. Group Classification Code

> 대상 항목에 관련있는 숫자나 문자를 이용해 코드를 부여하는 코드의 종류는 연상 코드(Mnemonic code)입니다. 따라서 정답은 **2번**입니다.
{: .prompt-info }

&nbsp;

### 31. 관찰대상의 데이터가 변환하면 이를 탐지하여 여러 가지 방식으로 사용자에게 출력하는 프로그램을 작성하고자 한다. 이 프로그램에 적용 가능한 디자인 패턴은?

1. Composite 패턴
2. Facade 패턴
3. Bridge 패턴
4. Observer패턴

> 한 객체의 상태가 변화하면 다른 객체들에게 변화한 상태를 전달하는 패턴을 Observer 패턴이라고 합니다. 따라서 정답은 **4번**입니다.
{: .prompt-info }

&nbsp;

### 32. 다음 중 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 긴능을 간편하게 사용할 수 있드록 하는 패턴은?

1. Abstract Factory 패턴
2. Facade 패턴
3. Singleton 패턴
4. Interpreter 패턴

> 설명에 대한 답은 퍼싸드(Facade) 패턴입니다. 따라서 정답은 **2번**입니다.
{: .prompt-info }

&nbsp;

### 33. 다음 중 디자인 패턴에 대한 설명으로 가장 옳지 않은 것은?

1. Singleton : 하나의 객체를 생성하여 해당 객체를 어디서든 참조할 수 있도록 한다.
2. Bridge : 구현에서 추상을 분리하여, 독립적으로 다양성을 가질 수 있다.
3. Chain of Responsibility : 한 객체가 처리하지 못한 요청을 다음 객체가 처리하는 형태이다.
4. Strategy : 알고리즘을 하나로 캡슐화하여 원하는 알고리즘의 선택이 가능하지만, 알고리즘의 변경이 미치는 영향이 크다.

> 전략(Strategy) 패턴은 알고리즘을 '개별적으로' 캡슐화하여 필요할 때마다 알고리즘을 선택하는 패턴이고, 일반적으로 클라이언트에 '영향 없이' 알고리즘의 변경이 가능합니다. 따라서 정답은 **4번**입니다.
{: .prompt-info }

&nbsp;

### 34. 차량 네비게이션 소프트웨어에서 GPS를 수신하는 경우와 수신하지 못하는 경우에 따라 위치를 구하는 다른 알고리즘을 선택하고자 할 때 가장 적합한 설계 패턴은?

1. 데코레이터 패턴
2. 전략 패턴
3. 어댑터 패턴
4. 플라이웨이트 패턴

> 필요할 때마다 알고리즘을 선택하는 패턴은 전략(Strategy) 패턴입니다. 따라서 정답은 **2번**입니다.
{: .prompt-info }

&nbsp;

### 35. 다음 중 성격이 다른 설계 패턴은?

1. 상태(State) 패턴
2. 전략(Strategy) 패턴
3. 메멘토(Memento) 패턴
4. 컴포지트(Composite) 패턴

> 상태, 전략, 메멘토 패턴은 행위 패턴이고, 컴포지트 패턴은 구조 패턴입니다. 따라서 정답은 **4번**입니다.
{: .prompt-info }

&nbsp;

### 36. 상속을 사용하지 않고도 객체의 기능을 동적으로 확장할 수 있도록 해주는 설계 패턴은?

1. 데코레이터(Decorator) 패턴
2. 프록시(Proxy) 패턴
3. 빌더(Builder) 패턴
4. 커맨드(Command) 패턴

> 객체에 다른 객체를 덧붙이는 방식으로 구현하여 기능을 동적으로 확장할 수 있는 설계 패턴은 데코레이터(Decorator) 패턴입니다. 따라서 정답은 **1번**입니다.
{: .prompt-info }

&nbsp;

### 37. 여러 객체들이 서로 메시지를 주고받는 상호작용을 특정 객체 안에 캡슐화하여 서로의 존재를 모르는 상태에서도 메시지를 주고받으며 협력할 수 있도록 하는 설계 패턴은?

1. Template Method
2. Mediator
3. Visitor
4. Bridge

> 객체들 간의 '상호작용을 캡슐화'하여 협력할 수 있도록 하는 설계 패턴은 중재자(Mediator) 패턴입니다. 따라서 정답은 **2번**입니다.
{: .prompt-info }